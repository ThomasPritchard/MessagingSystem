# Messaging Exercise - SOLUTION

# Extending the messaging system.

* Link to my repository - https://git.cs.bham.ac.uk/txp761/TXP761FirstYear/tree/master/Assignments/MessagingSystem/code

## How I went about with my solution

## Register

The way I had implemented the register function on my messaging system was that I created 2 extra classes. These consisted of ClientRegister and ServerRegister.
These classes would act as threads which would be run in parallel to the Client class in order to handle partially simultaneous registers between clients. The reason why it is
partial is because when the users want to register a password (this was included as an extra feature), one client has to wait for the other client to create their password before that client
can create his own password. This was done in such a way that other parts of the login and register was done more simultaneously and so was implemented successfully.

The way that the register system works as a whole is as follows. In the Client program, the user can type in a command 'register' in which he will be sent to the ClientRegister thread. Similarly, a message will be sent to the server to say that the client wants to register and so opens another thread called ServerRegister on the server side. This was done to enable efficient communication between the client and the server in storing relevant information about the client. Inside the ClientRegister thread, the client is asked what name he/she would like to have registered on the system. This name is then sent to the server which checks in the nickname table if the user exists. If they do not exist, their name will be added to the table. If the user already exists, then the server will send a message back, telling the user that they need to send another name over. If the name is okay to be added, the server will then ask the user what password they would like associated with their account. This is a feature that I have implemented separately in the system. Once the user has been created, they then go to the login page in which they can login with their newly created account (if they so wish to) and sign into the messaging system.

## Login  

The login procedure works similarly to the register procedure. I have created an extra two classes called ClientLogin and ServerLogin which act as threads in order to have the client and server communicate with each other to get the client to login successfully and efficiently.

The way this works is that inside the Client program, if the user types in 'login' the program will then run the ClientLogin thread as well as the server starting the ServerLogin thread. Inside the ClientLogin thread, the thread will ask the client for its username. This username will then be sent to the server via an output stream and buffered reader and then server will then check the nickname table to see if the username exists. If it does exist, it will then send a message back by either 'true' or 'false' which is a message of acknowledgement to the client to see if the username exists. If it is true, then the user will be asked to input their password. The server will again then check the relevant table to see if the password is correct and if so, the acknowledgement signal will be passed to the client, initiating the login phase. Once the login details are correct, the client login class will create the client sender and reciever threads and will start the main messaging system function. On the server side, the server will then also start the ServerSender and reciever classes as threads so they can run in parallel. In addition to this, the user's name will be added to a login table in order to show that they are currently logged in and available. This would be used more widely as a way of showing that they are 'active'. The login table is also used as a way to prevent two logins from the same user to happen on different client programs. I decided to implement it this way since I felt it would be a better thing to do.

## Logout

For the logout feature, this becomes available to the user as soon as the person has logged in. Upon logging in, they get the chance to either send a message, or type logout. If the user types logout, a message called 'logout' will be sent to the server. The server will then recieve this logout message and will have it act like a signal for the threads to close in order to logout the user.

The way this is done is that the client's name will be taken out of the login table but kept in the clientTable. The reason for this is so that the user still recieves messages sent by a client but will not be able to read them until they have logged back in. This is a useful feature for if the client wants to log back in to see any unread messages. After the name has been taken out of the login table, the server will then send the logout signal to the client reciever via the ServerSender thread and will break the while loop inside of ServerSender and Reciever in order to end each of those threads. The ClientReciever will then have the message and just end the thread as well. Using break inside of these while loops will terminate the threads efficiently and will help to join and close the threads in the Client class. The way I have implemented this feature is that I have done it in a way that the logout only stops the session of that user but not the client as a whole. What it will do instead is after logout, it will take the user back to the main menu where they can login as someone else or register another user. In doing this, new sockets and threads will be made for this user. If the user wants to leave the program altogether, they can type in 'quit' instead and the program will end the appropriate threads right up to the end and then will perform System.exit() but this happens in such a way that no exceptions are being catched on either side of the program.

## Keeping all messages recieved by any user

In order to keep any messages recieved by any user, this is done by keeping the messages inside of the blockingQueue for the user to recieve upon login. When the user then logs in, they shall recieve any message of any quantity in the order that they were sent. This was done by keeping the 'clientName' inside of the blockingQueue but takes the clientname outside of the login table to show that they are not available. This means that the server will not send any messages to the user until their name shows up inside of the login table.

## New syntax and semantics to send messages

For this feature, I had changed the syntax to send messages by using a command called 'send'. The way this now works is that the client uses a BufferedReader to read the command that the client wants to use. When the client types in 'send', the client will then ask the user to type in a recipient and message in which this will be sent to the server in the usual manner. If the user types in a command that does not exist, a message will be sent back to the client saying to type the command in again since it did not recognise that specific command. If the client is not logged in, they will still be able to recieve messages but instead of it explicitly showing up, the message gets stored in the list of messages for the client, which will then be shown to them on the next log in.  

## Previous, next and delete

I have implemented this feature in such a way that the user can see a history of exactly what messages have been sent and recieved by using three commands; 'previous', 'next' and 'current'. The way I wanted to approach is feature is that the client (once logged in), has the ability to type these three commands to see what messages they have been sending to people and what messaged they have had recieved by others. In addition, the delete command is there for user's that want to delete a message that they are currently viewing.

The program is able to track these messages through the idea of a table. Whenever a user sends or recieves messages, these messages get added to an instance of the ContentTable class. ContentTable is a generic table that I have made for string-based data to allow instances to be made such as LoginTable and MessageTable. When they get added, the user is then able to access them. The messages are added either through ClientSender when a client sends a message, or ClientReciever when a client recieves a message. MessageTable is made in the client-side, so whenever the user wants to access a message, he is doing it on his side rather than the server side. This is done so each individual Client can access their own messages instead of having all messages shared within the server.

For a user to access a message, they can type one of the three commands and the program will then return back to the Client the message at which the pointer was lying on. The position of the pointer will be typically on the current message until the user changes it over. When they type previous, the pointer will move one position behind, check if the item in that list is available to get (i.e. check if there is an item) and then return that to the user. Similarly, this is the same for next. If there is no item available that the user is trying to access, the program returns a message back saying that the user cannot access this item. The user can also get the message that the pointer is currently on by typing 'current'. If they then want to delete the message, they can type 'delete' which then takes the current message out of the messageTable and then moves the pointer to the next available message which will then become the new 'current' message.

## Self-Chosen feature

One feature that I have decided to implement first is a simple password system. This is a very simple system that is also unencrypted but shows the basic foundations of what a proper password system could be like. When the user goes to register their account, they can type in a username as well as a password. The password is then placed in the nickname table next to the username (the system was developed such that the password will always be placed next to the nickname. If two users register at the same time, one has to wait for their password to be entered first before the other can enter theirs). When the user then goes to login, the server will check the username then the item next to the username (the password) to see if both are correct before they fully log the client in successfully. 
